# API Endpoint Implementation Plan: GET /plans

## 1. Endpoint Overview

This endpoint retrieves a paginated list of workout plans belonging to the authenticated user. It allows users to view all their created workout plans with basic information (id, name, creation date) without nested exercise details. The endpoint supports pagination to efficiently handle users with many workout plans.

**Key Features:**

- Returns user's workout plans only (filtered by authentication)
- Supports pagination via query parameters
- Returns total count for pagination UI
- Lightweight response (no nested exercise data)

## 2. Request Details

### HTTP Method

`GET`

### URL Structure

```
/plans
```

### Authentication

- **Required**: JWT Bearer token in Authorization header
- **Format**: `Authorization: Bearer <token>`

### Query Parameters

| Parameter | Type   | Required | Default | Validation | Description                       |
| --------- | ------ | -------- | ------- | ---------- | --------------------------------- |
| `limit`   | number | No       | 20      | 1-100      | Maximum number of plans to return |
| `offset`  | number | No       | 0       | ≥0         | Number of plans to skip           |

### Request Example

```http
GET /plans?limit=20&offset=0 HTTP/1.1
Host: api.mygymtracker.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## 3. Used Types

### Query DTO (Needs Creation)

```typescript
export class WorkoutPlanQueryDto {
  @ApiProperty({
    description: "Maximum number of items to return",
    example: 20,
    required: false,
    minimum: 1,
    maximum: 100,
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  @Type(() => Number)
  limit?: number = 20;

  @ApiProperty({
    description: "Number of items to skip",
    example: 0,
    required: false,
    minimum: 0,
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  @Type(() => Number)
  offset?: number = 0;
}
```

### Response DTOs (Already Defined in types.ts)

- `WorkoutPlanListItemDto`: Single plan item
  - `id`: UUID
  - `plan_name`: string
  - `created_at`: Date
- `WorkoutPlanListDto`: Paginated response
  - `items`: WorkoutPlanListItemDto[]
  - `total`: number

### Entity Mapping

- Database table: `workout_plans`
- TypeORM Entity: `WorkoutPlan` (needs creation)

## 4. Response Details

### Success Response (200 OK)

```json
{
  "items": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "plan_name": "Push Day",
      "created_at": "2025-10-14T12:00:00.000Z"
    },
    {
      "id": "660e8400-e29b-41d4-a716-446655440001",
      "plan_name": "Pull Day",
      "created_at": "2025-10-13T10:30:00.000Z"
    }
  ],
  "total": 5
}
```

### Empty Result (200 OK)

```json
{
  "items": [],
  "total": 0
}
```

### Status Codes

| Code | Scenario                          | Response Body                                                                                   |
| ---- | --------------------------------- | ----------------------------------------------------------------------------------------------- |
| 200  | Success (with or without results) | WorkoutPlanListDto                                                                              |
| 400  | Invalid query parameters          | `{ "statusCode": 400, "message": ["limit must be between 1 and 100"], "error": "Bad Request" }` |
| 401  | Missing or invalid JWT token      | `{ "statusCode": 401, "message": "Unauthorized" }`                                              |
| 500  | Server error                      | `{ "statusCode": 500, "message": "Internal server error" }`                                     |

## 5. Data Flow

### Request Flow

```
1. Client Request
   └─> GET /plans?limit=20&offset=0
   └─> Authorization: Bearer <token>

2. NestJS Middleware Layer
   └─> Global ValidationPipe validates query params
   └─> Transform string params to numbers

3. JWT Guard
   └─> Validate JWT token
   └─> Extract user_id from token payload
   └─> Attach user to request object

4. Controller Layer (WorkoutPlansController)
   └─> @Get() decorated method
   └─> Extract query params (WorkoutPlanQueryDto)
   └─> Extract user from @Request() decorator
   └─> Call service method: workoutPlansService.findUserPlans(userId, query)

5. Service Layer (WorkoutPlansService)
   └─> Build TypeORM query with WHERE user_id = :userId
   └─> Apply pagination: .skip(offset).take(limit)
   └─> Execute query: findAndCount()
   └─> Map entities to WorkoutPlanListItemDto[]
   └─> Return WorkoutPlanListDto { items, total }

6. Response
   └─> Controller returns WorkoutPlanListDto
   └─> NestJS serializes to JSON
   └─> HTTP 200 with response body
```

### Database Query

```sql
-- Generated by TypeORM
SELECT
  wp.id,
  wp.plan_name,
  wp.created_at
FROM workout_plans wp
WHERE wp.user_id = $1
ORDER BY wp.created_at DESC
LIMIT $2 OFFSET $3;

-- Count query
SELECT COUNT(*) FROM workout_plans WHERE user_id = $1;
```

### Service Method Signature

```typescript
async findUserPlans(
  userId: string,
  query: WorkoutPlanQueryDto
): Promise<WorkoutPlanListDto>
```

## 6. Security Considerations

### Authentication & Authorization

1. **JWT Authentication**

   - Use `@UseGuards(JwtAuthGuard)` on controller method
   - Guard validates token signature and expiration
   - Extract user_id from token payload

2. **User Isolation**

   - Always filter by `user_id` in WHERE clause
   - Never trust client-provided user_id
   - Use authenticated user's ID from JWT token

3. **Row-Level Security (RLS)**
   - Database has RLS policy: `workout_plans_user_policy`
   - Policy enforces: `user_id = current_setting('app.user_id')::uuid`
   - If using RLS, set session variable before query
   - Alternative: Filter in application layer (WHERE clause)

### Input Validation

1. **Query Parameter Sanitization**

   - Use `class-validator` decorators in DTO
   - `@Type(() => Number)` for type transformation
   - `@Min()` and `@Max()` for range validation
   - Prevents SQL injection (TypeORM uses parameterized queries)

2. **Pagination Limits**
   - Enforce maximum limit (100) to prevent resource exhaustion
   - Default values prevent undefined behavior

### Data Exposure Prevention

- Only return fields specified in `WorkoutPlanListItemDto`
- Exclude sensitive fields: `user_id`, `updated_at`
- Use class-transformer `@Exclude()` if needed

### Rate Limiting

- Consider implementing rate limiting middleware
- Suggested: 100 requests per minute per user
- Prevents abuse and DoS attacks

## 7. Error Handling

### Error Scenarios

| Error Type                | HTTP Code | Cause                                          | Handler                       | Response                                                                                           |
| ------------------------- | --------- | ---------------------------------------------- | ----------------------------- | -------------------------------------------------------------------------------------------------- |
| Authentication Error      | 401       | Missing/invalid JWT                            | JwtAuthGuard                  | `{ "statusCode": 401, "message": "Unauthorized" }`                                                 |
| Validation Error          | 400       | Invalid query params (limit > 100, offset < 0) | ValidationPipe                | `{ "statusCode": 400, "message": ["limit must not be greater than 100"], "error": "Bad Request" }` |
| Type Error                | 400       | Non-numeric query params                       | ValidationPipe with transform | `{ "statusCode": 400, "message": ["limit must be a number"], "error": "Bad Request" }`             |
| Database Connection Error | 500       | DB unreachable                                 | Global exception filter       | `{ "statusCode": 500, "message": "Internal server error" }`                                        |
| Unexpected Error          | 500       | Unhandled exception                            | Global exception filter       | `{ "statusCode": 500, "message": "Internal server error" }`                                        |

### Error Handling Implementation

1. **Controller Level**

```typescript
// Automatic validation via ValidationPipe
@Get()
@UseGuards(JwtAuthGuard)
async findAll(
  @Query() query: WorkoutPlanQueryDto,
  @Request() req,
): Promise<WorkoutPlanListDto> {
  // No try-catch needed - NestJS handles exceptions
  return this.workoutPlansService.findUserPlans(req.user.id, query);
}
```

2. **Service Level**

```typescript
async findUserPlans(
  userId: string,
  query: WorkoutPlanQueryDto,
): Promise<WorkoutPlanListDto> {
  try {
    const [plans, total] = await this.workoutPlanRepository.findAndCount({
      where: { user_id: userId },
      select: ['id', 'plan_name', 'created_at'],
      order: { created_at: 'DESC' },
      skip: query.offset,
      take: query.limit,
    });

    return {
      items: plans,
      total,
    };
  } catch (error) {
    // Log error with context
    this.logger.error(
      `Failed to fetch workout plans for user ${userId}`,
      error.stack,
    );
    throw new InternalServerErrorException('Failed to fetch workout plans');
  }
}
```

3. **Global Exception Filter**

- NestJS built-in exception filter handles all HTTP exceptions
- Custom exception filter can be added for enhanced logging

### Logging Strategy

- Log all errors with context (user_id, query params)
- Use NestJS Logger service
- Include stack traces for 500 errors
- Don't expose internal error details to client

## 8. Performance Considerations

### Database Optimization

1. **Indexes**

   - Ensure index on `workout_plans.user_id` for fast filtering
   - Composite index on `(user_id, created_at DESC)` for sorted queries
   - Existing index: `idx_workout_sessions_user_completed` (not applicable)
   - **Recommendation**: Add index `CREATE INDEX idx_workout_plans_user_created ON workout_plans (user_id, created_at DESC);`

2. **Query Optimization**

   - Use `select` to fetch only required fields
   - Avoid N+1 queries (not applicable - no joins in this endpoint)
   - Use `findAndCount()` for efficient total count

3. **Connection Pooling**
   - TypeORM manages connection pool automatically
   - Configure appropriate pool size in TypeORM config

### Response Optimization

1. **Pagination Strategy**

   - Default limit (20) balances payload size and UX
   - Maximum limit (100) prevents large response payloads
   - Offset-based pagination is simple but has limitations at scale

2. **Caching Considerations**

   - Consider Redis caching for frequently accessed plans
   - Cache invalidation on plan create/update/delete
   - Cache key: `user:${userId}:plans:${offset}:${limit}`
   - TTL: 5-10 minutes

3. **Response Size**
   - Lightweight response (no nested exercises)
   - Estimated size: ~150 bytes per plan
   - 20 plans ≈ 3KB response

### Scalability Considerations

1. **Large Offset Problem**

   - Offset-based pagination becomes slow with large offsets
   - For offset > 10,000, consider cursor-based pagination
   - Monitor query performance with large datasets

2. **Alternative Pagination**
   - Future enhancement: cursor-based pagination using `created_at`
   - More efficient for large datasets
   - Example: `?cursor=2025-10-14T12:00:00.000Z&limit=20`

## 9. Implementation Steps

### Step 1: Create TypeORM Entity

**File**: `backend/src/workout-plans/entities/workout-plan.entity.ts`

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";

@Entity("workout_plans")
export class WorkoutPlan {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "uuid" })
  user_id: string;

  @Column({ type: "varchar", length: 100 })
  plan_name: string;

  @CreateDateColumn({ type: "timestamptz" })
  created_at: Date;

  @UpdateDateColumn({ type: "timestamptz", nullable: true })
  updated_at: Date | null;
}
```

### Step 2: Add Query DTO to types.ts

**File**: `backend/src/types.ts`

Add the `WorkoutPlanQueryDto` class after the workout plan section:

```typescript
/**
 * Query parameters for workout plan listing
 */
export class WorkoutPlanQueryDto {
  @ApiProperty({
    description: "Maximum number of items to return",
    example: 20,
    required: false,
    minimum: 1,
    maximum: 100,
  })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  @Type(() => Number)
  limit?: number = 20;

  @ApiProperty({
    description: "Number of items to skip",
    example: 0,
    required: false,
    minimum: 0,
  })
  @IsOptional()
  @IsInt()
  @Min(0)
  @Type(() => Number)
  offset?: number = 0;
}
```

### Step 3: Create Workout Plans Module

**File**: `backend/src/workout-plans/workout-plans.module.ts`

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { WorkoutPlansController } from "./workout-plans.controller";
import { WorkoutPlansService } from "./workout-plans.service";
import { WorkoutPlan } from "./entities/workout-plan.entity";

@Module({
  imports: [TypeOrmModule.forFeature([WorkoutPlan])],
  controllers: [WorkoutPlansController],
  providers: [WorkoutPlansService],
  exports: [WorkoutPlansService],
})
export class WorkoutPlansModule {}
```

### Step 4: Create Service

**File**: `backend/src/workout-plans/workout-plans.service.ts`

```typescript
import {
  Injectable,
  InternalServerErrorException,
  Logger,
} from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { WorkoutPlan } from "./entities/workout-plan.entity";
import { WorkoutPlanListDto, WorkoutPlanQueryDto } from "../types";

@Injectable()
export class WorkoutPlansService {
  private readonly logger = new Logger(WorkoutPlansService.name);

  constructor(
    @InjectRepository(WorkoutPlan)
    private readonly workoutPlanRepository: Repository<WorkoutPlan>
  ) {}

  /**
   * Find all workout plans for a specific user with pagination
   * @param userId - User's UUID
   * @param query - Pagination parameters
   * @returns Paginated list of workout plans
   */
  async findUserPlans(
    userId: string,
    query: WorkoutPlanQueryDto
  ): Promise<WorkoutPlanListDto> {
    if (!userId) {
      this.logger.error("findUserPlans called with undefined userId");
      throw new InternalServerErrorException("User ID is required");
    }

    try {
      const { limit = 20, offset = 0 } = query;

      const [plans, total] = await this.workoutPlanRepository.findAndCount({
        where: { user_id: userId },
        select: ["id", "plan_name", "created_at"],
        order: { created_at: "DESC" },
        skip: offset,
        take: limit,
      });

      this.logger.log(
        `Found ${plans.length} workout plans for user ${userId} (total: ${total})`
      );

      return {
        items: plans,
        total,
      };
    } catch (error) {
      this.logger.error(
        `Failed to fetch workout plans for user ${userId}`,
        error.stack
      );
      throw new InternalServerErrorException("Failed to fetch workout plans");
    }
  }
}
```

### Step 5: Create Controller

**File**: `backend/src/workout-plans/workout-plans.controller.ts`

```typescript
import { Controller, Get, Query, Request, UseGuards } from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiQuery,
} from "@nestjs/swagger";
import { WorkoutPlansService } from "./workout-plans.service";
import { JwtAuthGuard } from "../auth/guards/jwt-auth.guard";
import { WorkoutPlanListDto, WorkoutPlanQueryDto } from "../types";

@ApiTags("Workout Plans")
@Controller("plans")
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class WorkoutPlansController {
  constructor(private readonly workoutPlansService: WorkoutPlansService) {}

  @Get()
  @ApiOperation({
    summary: "List user's workout plans",
    description:
      "Retrieve a paginated list of workout plans belonging to the authenticated user",
  })
  @ApiQuery({
    name: "limit",
    required: false,
    type: Number,
    description: "Maximum number of plans to return (1-100)",
    example: 20,
  })
  @ApiQuery({
    name: "offset",
    required: false,
    type: Number,
    description: "Number of plans to skip",
    example: 0,
  })
  @ApiResponse({
    status: 200,
    description: "Successfully retrieved workout plans",
    type: WorkoutPlanListDto,
  })
  @ApiResponse({
    status: 400,
    description: "Invalid query parameters",
  })
  @ApiResponse({
    status: 401,
    description: "Unauthorized - invalid or missing JWT token",
  })
  @ApiResponse({
    status: 500,
    description: "Internal server error",
  })
  async findAll(
    @Query() query: WorkoutPlanQueryDto,
    @Request() req
  ): Promise<WorkoutPlanListDto> {
    return this.workoutPlansService.findUserPlans(req.user.id, query);
  }
}
```

### Step 6: Register Module in App Module

**File**: `backend/src/app.module.ts`

```typescript
import { WorkoutPlansModule } from "./workout-plans/workout-plans.module";

@Module({
  imports: [
    // ... existing imports
    WorkoutPlansModule,
  ],
  // ... rest of module
})
export class AppModule {}
```

### Step 7: Add Database Index (Optional but Recommended)

**File**: `backend/src/db/migrations/[timestamp]-AddWorkoutPlansIndex.ts`

```typescript
import { MigrationInterface, QueryRunner } from "typeorm";

export class AddWorkoutPlansIndex1729000000000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE INDEX IF NOT EXISTS idx_workout_plans_user_created 
      ON workout_plans (user_id, created_at DESC)
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      DROP INDEX IF EXISTS idx_workout_plans_user_created
    `);
  }
}
```

### Step 8: Configure Global Validation Pipe

**File**: `backend/src/main.ts`

Ensure the global validation pipe is configured:

```typescript
app.useGlobalPipes(
  new ValidationPipe({
    transform: true, // Enable auto-transformation
    whitelist: true, // Strip unknown properties
    forbidNonWhitelisted: true, // Throw error on unknown properties
    transformOptions: {
      enableImplicitConversion: false, // Require explicit @Type() decorators
    },
  })
);
```

### Step 9: Add Required Imports to types.ts

**File**: `backend/src/types.ts`

Add validation decorator imports at the top:

```typescript
import { IsOptional, IsInt, Min, Max } from "class-validator";
import { Type } from "class-transformer";
```

### Step 10: Write Unit Tests

**File**: `backend/src/workout-plans/workout-plans.service.spec.ts`

```typescript
import { Test, TestingModule } from "@nestjs/testing";
import { getRepositoryToken } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { WorkoutPlansService } from "./workout-plans.service";
import { WorkoutPlan } from "./entities/workout-plan.entity";
import { InternalServerErrorException } from "@nestjs/common";

describe("WorkoutPlansService", () => {
  let service: WorkoutPlansService;
  let repository: Repository<WorkoutPlan>;

  const mockRepository = {
    findAndCount: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        WorkoutPlansService,
        {
          provide: getRepositoryToken(WorkoutPlan),
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<WorkoutPlansService>(WorkoutPlansService);
    repository = module.get<Repository<WorkoutPlan>>(
      getRepositoryToken(WorkoutPlan)
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("findUserPlans", () => {
    it("should return paginated workout plans", async () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";
      const mockPlans = [
        {
          id: "660e8400-e29b-41d4-a716-446655440001",
          plan_name: "Push Day",
          created_at: new Date("2025-10-14T12:00:00.000Z"),
        },
      ];
      const total = 5;

      mockRepository.findAndCount.mockResolvedValue([mockPlans, total]);

      const result = await service.findUserPlans(userId, {
        limit: 20,
        offset: 0,
      });

      expect(result).toEqual({ items: mockPlans, total });
      expect(mockRepository.findAndCount).toHaveBeenCalledWith({
        where: { user_id: userId },
        select: ["id", "plan_name", "created_at"],
        order: { created_at: "DESC" },
        skip: 0,
        take: 20,
      });
    });

    it("should return empty array when no plans exist", async () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";

      mockRepository.findAndCount.mockResolvedValue([[], 0]);

      const result = await service.findUserPlans(userId, {
        limit: 20,
        offset: 0,
      });

      expect(result).toEqual({ items: [], total: 0 });
    });

    it("should throw InternalServerErrorException on database error", async () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";

      mockRepository.findAndCount.mockRejectedValue(new Error("DB Error"));

      await expect(
        service.findUserPlans(userId, { limit: 20, offset: 0 })
      ).rejects.toThrow(InternalServerErrorException);
    });

    it("should apply custom pagination parameters", async () => {
      const userId = "550e8400-e29b-41d4-a716-446655440000";

      mockRepository.findAndCount.mockResolvedValue([[], 0]);

      await service.findUserPlans(userId, { limit: 50, offset: 10 });

      expect(mockRepository.findAndCount).toHaveBeenCalledWith(
        expect.objectContaining({
          skip: 10,
          take: 50,
        })
      );
    });
  });
});
```

### Step 11: Write E2E Tests

**File**: `backend/test/workout-plans.e2e-spec.ts`

```typescript
import { Test, TestingModule } from "@nestjs/testing";
import { INestApplication, ValidationPipe } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "../src/app.module";

describe("WorkoutPlansController (e2e)", () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({
        transform: true,
        whitelist: true,
        forbidNonWhitelisted: true,
      })
    );
    await app.init();

    // Login to get auth token
    const loginResponse = await request(app.getHttpServer())
      .post("/auth/login")
      .send({ email: "test@example.com", password: "password123" });
    authToken = loginResponse.body.accessToken;
  });

  afterAll(async () => {
    await app.close();
  });

  describe("GET /plans", () => {
    it("should return paginated workout plans", () => {
      return request(app.getHttpServer())
        .get("/plans")
        .set("Authorization", `Bearer ${authToken}`)
        .expect(200)
        .expect((res) => {
          expect(res.body).toHaveProperty("items");
          expect(res.body).toHaveProperty("total");
          expect(Array.isArray(res.body.items)).toBe(true);
          expect(typeof res.body.total).toBe("number");
        });
    });

    it("should apply pagination parameters", () => {
      return request(app.getHttpServer())
        .get("/plans?limit=10&offset=5")
        .set("Authorization", `Bearer ${authToken}`)
        .expect(200);
    });

    it("should reject invalid limit", () => {
      return request(app.getHttpServer())
        .get("/plans?limit=200")
        .set("Authorization", `Bearer ${authToken}`)
        .expect(400);
    });

    it("should reject negative offset", () => {
      return request(app.getHttpServer())
        .get("/plans?offset=-1")
        .set("Authorization", `Bearer ${authToken}`)
        .expect(400);
    });

    it("should reject non-numeric parameters", () => {
      return request(app.getHttpServer())
        .get("/plans?limit=abc")
        .set("Authorization", `Bearer ${authToken}`)
        .expect(400);
    });

    it("should return 401 without auth token", () => {
      return request(app.getHttpServer()).get("/plans").expect(401);
    });
  });
});
```

### Step 12: Test the Endpoint

1. **Start the application**:

   ```bash
   cd backend
   npm run start:dev
   ```

2. **Test with curl**:

   ```bash
   # Get auth token first
   TOKEN=$(curl -X POST http://localhost:3000/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"password123"}' \
     | jq -r '.accessToken')

   # Test GET /plans
   curl -X GET "http://localhost:3000/plans?limit=20&offset=0" \
     -H "Authorization: Bearer $TOKEN"
   ```

3. **Verify Swagger documentation**:
   - Navigate to `http://localhost:3000/api`
   - Locate "Workout Plans" section
   - Test the GET /plans endpoint

### Step 13: Monitoring and Logging

Add monitoring for production:

1. **Log query performance**:

```typescript
const startTime = Date.now();
const [plans, total] = await this.workoutPlanRepository.findAndCount(...);
const duration = Date.now() - startTime;

if (duration > 1000) {
  this.logger.warn(`Slow query: findUserPlans took ${duration}ms for user ${userId}`);
}
```

2. **Add metrics collection** (if using Prometheus):

```typescript
this.metricsService.recordQueryDuration(
  "workout_plans",
  "findAndCount",
  duration
);
```

## 10. Testing Checklist

- [ ] Unit tests for service methods
- [ ] E2E tests for controller endpoints
- [ ] Test successful retrieval with default pagination
- [ ] Test successful retrieval with custom pagination
- [ ] Test empty result set
- [ ] Test authentication failure (no token)
- [ ] Test authentication failure (invalid token)
- [ ] Test validation errors (limit > 100)
- [ ] Test validation errors (offset < 0)
- [ ] Test validation errors (non-numeric parameters)
- [ ] Test database connection failure
- [ ] Verify Swagger documentation accuracy
- [ ] Test query performance with large datasets
- [ ] Verify only user's own plans are returned

## 11. Documentation Requirements

- [ ] Update API documentation with endpoint details
- [ ] Add Swagger annotations to controller
- [ ] Document query parameters in Swagger
- [ ] Add example responses in Swagger
- [ ] Update README with endpoint usage
- [ ] Document rate limiting policies (if implemented)
